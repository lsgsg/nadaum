import React from "react";
import App from "./components/App";
//import { createStore } from 'redux';  // v
//import reducers from './reducers'; // v
import store from "./store/configure";
import { Provider } from "react-redux";
// store를 제공한느 역할 , 전체 앱을 Provider로 감싸줄거다.
//const store = createStore(reducers) //v
import { BrowserRouter } from "react-router-dom";



const Root = () => {
    return (
        <Provider store={store}>
            <BrowserRouter>
                <App />
            </BrowserRouter>
        </Provider>
    )
};

export default Root;



// provider의 props로 store를 설정해라
// 아직 App 컴포넌트와 counter 컴포넌트에서 store에 접근을 하고 있는 것은 아니다.
// 따로 설정을 해주어야 한다.
// 여기서 2번째 핵심인 connect 함수가 나온다.
// connect([..options])
// 컴포넌트를 redux에 연결하는 함수를 반환하다.
// 이 함수는  옵션을 인수로 받고 전달받은 옵션을 사용하여 컴포넌트를 리덕스에 연결하는 또 다른 함수를 반환한다. "또다른 함수를 반환한다. "
// 그래서 그 함수에다가 이렇게 connect()(Counter) 해준다.
// store에 연결된 새로운 컴포넌트 클래스가 반환됨. 옵션이 없으면 this.props.store로 접근 가능하다.
// counter를 인수로 전달해주면 그 카운터가 리덕스에 연결이 된어 이 함수의 반환값으로 새로운 컴포넌트 클래스가 반환되는 것이다. 새로운 컴포넌트 클래스는 리덕스에 연결이 되어 있다. 그렇다고 해서 기존에 있던 counter컴포넌트가 변경되는 것은 아니다. " 새로운 컴포넌트가 반환 되는 것이다. "
// 만약에 지금 보고있는 것처럼 , connect에 옵션을 전달하지 않았다면 컴포넌트 내부에서 this.props.store로 접근을 할 수 있음. 그러면 렌더링을 할 때, 그 store를 사용해서  getstate로  특정 값을 가지고 오면된다. 아니면 변화를 일으킬 때, dispatch 하면되낟.
// 또 만약에 여기서 옵션을 넣으면 좀 더 깔끔하고 편해진다.
// 그 옵션이 무어냐면 ??

// mapStateToProps
// mapDispatchToProps
// mergeProps,
// options

// options 는 {[pure = ture],[withRef = false]}
// 앞의 세개는 함수 형태의 파라미터이다.
// mapStateToProps 는 state를 v파라미터로 가지는 함수이고
// state를 해당 컴포넌트의 props로 연결해준다.

// mapDispatchToProps 는 dispatch를 파라미터로 가진 함수이다.
// dispatch한 함수를 porps로 연결해준다.

// mergeProps는 state와 dispatch를 파라미터로 가져서 만약에 컴포넌트에 연결해야할 props가 state와 dispatch를 동시에 사용해야한다면 mergeProps를 쓰면된다.
// 보통은 사용될일이 업다.


// 마지막으로 options는 객체 현태를 가진다.
// pure와 withRef가 있다. pure는 기본적으로 ture로 설정되어있고, ture로 설정되어있으면 불필요한 업데이트를 하지 않는다. r그리고 withRef는 기본적으로 false이다.
// 만약에 이게 ture로 설정되어 있다면 - > 리덕스에 연결된 컴포넌트를 Ref에 담아서
// getWrappedInstance() 메소드를 통하여 접근 할 수 있게 할거다.
// 보통은 사용될일이 업다.



// 지금까지 redux 배경 지식을 배웠따.. 근데 사용해보지 않고 이해하기 힘들다 ...
// 많이 사용하면 쉬워진다.
// 리덕스의 아이디어만 이해한다면...
// 어려워도 정상이다.
// 최대한 이해하기 쉽게 설명하겠다.
// craet-react-app testredux
// 댄 에브라nov 가 rldux만들었다.


//eject : 설정파일들을 우리들이 사용하고자하는 프로젝트에 가지고 오는 것..
// 대신에 프로젝트 구조가 조금 복잡해짐...
// npm start
// npm install --save redux react-redux

// 코드를 작성해 보자
// 프로젝트 구조는
// 자동생성된 파일들을 지워라...
// 이중에서 다 지워..
// 아톰에디터를 사용하면 ...
























// flux 아키텍처를 좀 더 편하게 쓸 수 있게 만들어 놓은 것이 redux 이다.
// ㅣ이거 만든 개발자 페이스북에서 채용함...
// 각 노드들은 컴포넌트 들이다.
// 컴포넌트들은 스토어에 데이터를 담고,
// 빨간 화살표는 디스패치를 의미한다.
// 즉, 스토어에 있는 데이터를 업데이트 하는것
// 주황색 화살표는 subscribe를 의미한다.
// 해당컴포넌트에서 스토ㅓ에 있는 특정 데이터의 변동을 주시하고 있다가
// 변동이 있을 시 바로 반영한다.
// 예를 들어 빨간 컴포넌트에서 초록 컴포너느로 데이터 교류가 필요시에는
// 리덕스 가 없을때는 가지들을 계속 따라 올라가야하지만..
// 리둑스가 있다면 스토어에 넣어주면 바로 반영할 수 있다.
// 리둑스는 3가지 원칙이 있다.

// 단하나의 진실의 근원... 모든 진실은 하나의 근원에서 나온다.
// 단한개의 store를 쓴다. 이것이 flux와의 차이점이다. 여러개의 sotre를 쓴다.
// 둘, 스테이트는 읽기 전용이다. 스테이트를 변경하는 유일한 방법은 action객체를 전달하는 것이다. 직접 변경할 수 없다는 것이다. 무조건 action d이 디스패치 되어야한다.
// 셋, 액션 객체를 처리하는 함수를 reducer라고 한다. 상태를 어떻게 업데이트 할지 정의한다.
// 순수 함수로 정의 되어야 한다. reducer는...
// 즉, 비동기 처리를 하면 안된다는 것이다. 데이터 베이스 접근 X , 인수 변경 X
// t순수하지 않는 api 사용 불가......

// 스토어 : 단 한개의 스토어를 가지고 있다. dispatcer가 없다..
// 리듀서 : 변화를 일으키는 함수 , 리듀서는 여러개가 있을 수도 있다. 여러개의 리듀서를 관리한느 루트 리듀서가 있을 것이다. 한개일 때는 자신이 처리하고 리듀서가 여러개라면 전달받은 액션을 담당하는 리듀서에게 전달을 해준다. 누가? 루트 리듀서가...

// 리듀서는 복사를 열성적으로 한다. 예전상태는 변경하지 않고 새로 복사하여 거기다가 변경사항을 적용한다. 마치 지니처럼....

// 지니는 새로운 방을 만든다. 이게 바로 리듀서의 키 아이디어의 하나이다.
// 상태 객체가 직접 변경되지 ㅇ낳고, 복사된 상태객체가 변경됨

// 똑똑한 컴포넌트와 멍청한 컴포넌트 ....
// 또똑 : 액션처리 책임...
// 멍청 : 액션을 props 를 통해 전달받아 사용함..
// 똑똑 : 돔 X css X <-> 멍청
// 뷰 레이어 바인딩 : 스토어를 뷰에 연결하기 위해 ..(좀더 쉽게)
// 기술적인 세부사항을 지들이 처리한다. 마치 it 부서 처럼

// root 컴포넌트 : 모든 팀이 일을 하도록 하게하는 사장과 같다. 설정을 하고 나면 하는 일이 없다.

// 데이터 흐름 뷰 -> 액션 -> 뷰-> 스토어(액션) -> 루트 리듀서 -> 담당서브리듀서 -> 상태 사본make -< 변경 , 사본을 돌려줌 -> 루트 리듀서가 받아 한곳에 모아 -> sotre에게 .. -> 뷰에게 상태 변화를 알려줌 -> 새로운상태를 받음 -> 뷰 -> 화면의 특정부분을 업데이트 하다. 기억해라!
